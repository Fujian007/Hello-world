/** 这是一个插入排序
     *  不妨设: 从小到大
     */
    public static void insertSort(int[] arr){
        //最外层的for循环指的是需要插入的次数，
        // 显然，需要插入的次数就是数组总元素个数减一
        for (int i = 0; i < arr.length - 1; i++) {
            //取出需要插入的数的值
            int val = arr[i + 1];
            //获取取出数的索引值减一，因为需要先和它前面的第一个元素进行比较
            int index = i;
            /**
             *  while循环的条件：
             *  1，首先要保证循环的索引不能越界，插入排序是一个向前推进的过程
             *  2，比较数(arr[index])大于插入数(val)时，说明插入数当前所在位置不合适,
             *     先把刚刚比较的数(arr[index])后移一位，这里采用直接覆盖后面的数(val)，
             *     val的值已经保存，无需担心丢失，后移之后，需要继续向前推进比较，我们把索引值减一
             */
           while (index >= 0 && arr[index] > val){
               arr[index + 1] = arr[index];
               index--;
           }
            /**
             *  当跳出循环只有两种情况：
             *    1，索引值(index)=0;
             *    2, 比较数(arr[index])小于或者等于插入数(val)
             *     不管哪一种情况，插入数的排序位置也就是索引值已经确定下来:[index + 1]
             *  其实while循环中:arr[index + 1] = arr[index];
             *  可以成是交换的过程，前面的数覆盖后面的插入数，插入数也前移一位：arr[index] = val;
             *  但是，因为即使我们让插入数前移一位，那么插入数也不一定就排在了它应该在的位置，因为
             *  插入数的前面可能还存在其他数，他们的大小情况我们不得而知，所以，下次循环可能还需要交换，
             *  这样徒增功耗，增加时间复杂度，我们可以等循环结束，之后，只做一次赋值即可，我们可以看到
             *   while循环中最后一句：
             *   index--;
             *   我们把index减一后，在进入循环的，所以如果while中的条件不成立，说明插入数的索引值
             *   就是index，但我们已经对index减一操作了，所以，跳出循环后再对index加1即可。
             */
           arr[index + 1] = val;
        }
    }